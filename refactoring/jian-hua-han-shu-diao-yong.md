## 函数改名

函数的名称未能揭示函数的用途。**修改函数名称。**

![](http://wangvsa.github.io/refactoring-cheat-sheet/images/10fig01.gif)

**动机（Motivation）**

我极力提倡的一种编程风格就是：将复杂的处理过程分解成小函数。但是，如果做得不好，这会使你费尽周折却弄不清楚这些小函数各自的用途。要避免这种麻烦，关键就在于给函数起一个好名称。函数的名称应该准确表达它的用途。给函数命名有一个好办法：首先考虑应该给这个函数写上一句怎样的注释，然后想办法将注释变成函数名称。

人生不如意，十之八九。你常常无法第一次就给函数起一个好名称。这时候你可能会想：就这样将就着吧——毕竟只是一个名称而已。当心！这是恶魔的召唤，是通 向混乱之路，千万不要被它诱惑！如果你看到一个函数名称不能很好地表达它的用 途，应该马上加以修改。记住，你的代码首先是为人写的，其次才是为计算器写的。 而人需要良好名称的函数。想想过去曾经浪费的无数时间吧。如果给每个函数都起一个良好的名称，也许你可以节约好多时间。起一个好名称并不容易，需要经验； 要想成为一个真正的编程高手，「起名称」的水平是至关重要的。当然，函数签名式（signature）中的其他部分也一样重要；如果重新安排参数顺序，能够帮助提高代码的清晰度，那就大胆地去做吧，你有[添加参数](http://wangvsa.github.io/refactoring-cheat-sheet/making-method-calls-simpler/#_1)和[移除参数](http://wangvsa.github.io/refactoring-cheat-sheet/making-method-calls-simpler/#_7)这两项武器。

**作法（Mechanics）**

* 检查函数签名式（signature）是否被superclass 或subclass 实现过。如果是，则需要针对每份实现品分别进行下列步骤。
* 声明一个新函数，将它命名为你想要的新名称。将旧函数的代码拷贝到新函数中，并进行适当调整。
* 编译。
* 修改旧函数，令它将调用转发给新函数。
  * 如果只有少数几个地方引用旧函数，你可以大胆地跳过这一步骤。
* 编译，测试。
* 找出旧函数的所有被引用点，修改它们，令它们改而引用新函数。每次修改后，编译并测试。
* 删除旧函数。
  * 如果旧函数是class public 接口的一部分，你可能无法安全地删除它。这种情况下，将它保留在原处，并将它标记为"deprecated"（不再被赞同）。
* 编译，测试。

---

## 添加参数

某个函数需要从调用端得到更多信息。**为此函数添加一个对象参数，让该对象带进函数所需信息。**

![](http://wangvsa.github.io/refactoring-cheat-sheet/images/10fig02.gif)

**动机（Motivation）**

[添加参数](http://wangvsa.github.io/refactoring-cheat-sheet/making-method-calls-simpler/#_1)是一个很常用的重构手法，我几乎可以肯定已经用过它了。使用这项重构的动机很简单：你必须修改一个函数，而修改后的函数需要一些过去没有的信息，因此你需要给该函数添加一个参数。

实际上我比较需要说明的是：不使用本重构的时机。除了添加参数外，你常常还有其他选择。只要可能，其他选择都比本项「添加参数」要好，因为它们不会增加参数列的长度。过长的参数列是不好的味道，因为程序员很难记住那么多参数，而且长参数列往往伴随着坏味道Date Clumps。

请看看现有的参数，然后问自己：你能从这些参数得到所需的信息吗？如果回答是否定的，有可能通过某个函数提供所需信息吗？你究竟把这些信息用于何处？这个函数是否应该属于拥有该信息的那个对象所有？看看现有参数，考虑一下，加入新参数是否合适？也许你应该考虑使用[引入参数对象](http://wangvsa.github.io/refactoring-cheat-sheet/making-method-calls-simpler/#_4)。

我并非要你绝对不要添加参数。事实上我自己经常添加参数，但是在添加参数之前你有必要了解其他选择。

**作法（Mechanics）**

[添加参数](http://wangvsa.github.io/refactoring-cheat-sheet/making-method-calls-simpler/#_1)的作法和[重新命名函数](http://wangvsa.github.io/refactoring-cheat-sheet/making-method-calls-simpler/#_9)非常相似。

* 检查函数签名式（signature）是否被superclass 或subclass 实现过。如果是，则需要针对每份实现分别进行下列步骤。
* 声明一个新函数，名称与原函数同，只是加上新添参数。将旧函数的代码拷贝到新函数中。
  * 如果需要添加的参数不止一个，将它们一次性添加进去比较容易。
* 编译。
* 修改旧函数，令它调用新函数。
  * 如果只有少数几个地方引用旧函数，你大可放心地跳过这一步骤。
  * 此时，你可以给参数提供任意值。但一般来说，我们会给对象参数提供null ，给内置型参数提供一个明显非正常值。对于数值型参数，我建议使用0 以外的值，这样你比较容易将来认出它。
* 编译，测试。
* 找出旧函数的所有被引用点，将它们全部修改为对新函数的引用。每次修改后，编译并测试。
* 删除旧函数。
  * 如果旧函数是class public 接口的一部分，你可能无法安全地删除它。这种情况下，请将它保留在原地，并将它标示为"deprecated"（不再 被赞同）。
* 编译，测试。

---

## 移除参数

## 将查询函数和修改函数分离 {#_15}

## 令函数携带参数 {#_5}

## 以明确函数取代参数 {#_13}

## 保持对象完整 {#_6}

## 以函数取代参数 {#_14}

## 引入参数对象 {#_4}

## 移除设值函数 {#_8}

## 隐藏函数 {#_3}

## 以\[工厂函数\]取代\[构造函数\] {#_10}

## 封装\[向下转型\]动作 {#_2}

## 以异常取代错误码 {#_11}

## 以测试取代异常 {#_12}



