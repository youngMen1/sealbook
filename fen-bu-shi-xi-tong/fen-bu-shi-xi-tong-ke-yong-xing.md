# 1.基本介绍

## CAP定理

### C（一致性）：所有的节点上的数据时刻保持同步，对于事务只能同时的成功或者失败，即所有的备份数据已经完全和主数据完全一致。

* **强一致性：**这种一致性级别是最符合用户直觉的，它要求系统写入什么，读出来的也会是什么，用户体验好，但实现起来往往对系统的性能影响大。对于每个事务在提交后，只能出现成功或者失败两种状态，不存在中间状态。

* **弱一致性：**这种一致性级别约束了系统在写入成功后，不承诺立即可以读到写入的值，也不久承诺多久之后数据能够达到一致，但会尽可能地保证到某个时间级别（比如秒级别）后，数据能够达到一致状态。

* **最终一致性：**最终一致性是弱一致性的一个特例，系统会保证在一定时间内，能够达到一个数据一致的状态。这里之所以将最终一致性单独提出来，是因为它是弱一致性中非常推崇的一种一致性模型，也是业界在大型分布式系统的数据一致性上比较推崇的模型。

* **顺序一致性：**是指每个提交的事务会根据提交的顺序，使得系统的数据达到最终一致性状态。但是我们知道分布式系统是没有全局时钟的概念，因此在度量分布式事务的顺序时是不准确的，因此顺序一致性大部分是指同一节点提交事务的顺序，不是不同节点之间的顺序性。其中顺序最终一致性常用于redis等分布式数据库系统中。

### A（可用性）：每个请求都能在指定时间内接受到一个准确的响应（成功或者失败）。然而在分布式系统中还会出现超时这样一种不确定的状态。

在分布式系统中通信异常时最常见的一种异常，其是不可避免的，因此在一个请求发生时，如果发生通信异常，就会产生如下两种情况：1）请求没有到达目标系统，造成整个请求超时（请求未处理）。2）请求到达目标系统，但是在目标返回响应的过程中，响应信息丢失，造成整个请求超时（请求已经处理）。因此超时对于客户系统而言都是一种不确定的状态，其服务是不可用的状态。对于一个分布式系统假设每个机器或者节点产生网络故障的概率是P，那么整个分布式系统的极致可用性是1-P^N（N表示机器或者节点数量）。因此此处所说的可用性是指分布式系统的极致可用性，即只要有一台机器或者节点可用那么就要保证整个服务可用。

### P（分区容错性）：系统应该能持续提供服务，即使由于网络原因造成系统被分隔成很多个子系统（分区），任然能够提供服务。

网络问题是分布式系统不可避免的问题，并且是一定会发生的问题。因此对于分布式系统必须要具有分区容错性。例如：一个分布式系统需要有3个备份，其分区容错性为2，及要求必须有2个备份才能继续提供服务。因此如果其中一个备份的机器节点不可达，由于分区容错性的存在，其可以继续提供服务，并且分布式系统会根据情况等待该分区重新连接，恢复失去连接时的新增数据，之后再提供服务。或者由于节点宕机，会重新产生一个分区，并同步所有的数据（时间较长），等数据同步完成再开始进行服务。如果一个分布式系统不允许分区容错性，那么只要一个备份数据不可用，整个服务都不可用，这是用户不可接受的。

# 2.怎么使用

## 2.1.**分布式系统在CAP中的选型** {#3-分布式系统在cap中的选型}

### 2.1.1.**CA类型系统** {#31-ca类型系统}

单机数据库（CA类型）：由于数据库的是以事务为单位进行执行的而事务具有ACID的特性，因此能够保证数据时刻都是同步的。并且只要整个网络不瘫痪（及单机数据库不宕机）都能保证服务是可用的。因此单机数据库系统是具有CA特性的。

在数据库中主要是通过记录log日志（redo日志和undo日志）来保证数据的一致性。通过乐观锁（快照读，根据事务的不同执行时间，提供不同版本的快照数据，达到读不加锁，提高服务的可用性），对于需要加锁悲观锁的操作（update delete alter select for update\)通过当前读及对要处理的记录加锁\(gap锁\)来使得整个操作串行化的目的。

### 2.1.2.**CP类型系统（分布式数据库）**

**分布式数据库（半同步复制\)**：

主从同步延迟引起的数据不一致，可以通过消除主从延迟或者对有延迟的数据读主库来达到数据的强一致性。

**半同步复制**：

在客户端请求时，等从库同步完成后，再返回。  
![img](/static/image/20170418234317382.jpg)  
**方案优点：**利用数据库原生功能，比较简单  
**方案缺点：**主库的写请求时延会增长，吞吐量会降低。极端情况下，网络分区的出现，造成整个服务不可用。

**分布式数据库（数据库中间件）：**

由中间件根据主从同步的完成情况来决定是查主库还是从库。

![img](/static/image/20170419001113631.jpg)
**方案优点：**在中间件性能不存在问题的情况下，吞吐量比半同步复制高很多倍，略低于主从类型数据的写性能。 
**方案缺点：**对中间件性能要求很高，所有的请求都需要经过中间件进行路由，容易造成单点故障，当出现分区时所有请求都路由到主库，容易造成主库宕机。并且读写性能都有略微下降。

**分布式数据库（缓存更新记录）：**预估主从延迟的最大时间作为缓存过期时间，对于刚更新的数据，将key缓存到缓存中，当读请求时，先查缓存，命中查主库，未命中查从库。 
**方案优点：**写性能同直接写主库相比性能下降很少。有较高的吞吐量。 
**方案缺点：**读写都要先操作缓存数据，会对性能有所影响。过期时间难以保证，可能出现不是强一致性的情况。 
上述类型的数据库方案都是牺牲了可用性来保证数据的强一致性。

**分段提交协议（zookeeper) **
略（待补充）。zookeeper通过实现分段提交协议（zab协议）来使得其具有强一致性和分区容错性的特点，其大量用于解决分布式中间件在遇到脑裂时的主-备选举和数据恢复的功能。

在分布式系统中，每个单机系统都可以通过本地事务来准确的知道自己处理的结果是成功或者失败。因此对于分布式系统我们可以提供一个协调者来统一调度分布式节点（参与者）的事务，并根据分布式节点（参与者）的处理结果来决定各个分布式节点的事务是否真正的提交，根据这种思路提出了两阶段提交和三阶段提交的分布式事务协议。

#### 2.1.3.二阶段提交协议： 
**阶段1：提交事务请求**

事务询问。协调者向所有参与者发送事务内容，询问是否可以执行事务提交操作，并等待各个参与者的回应。
执行事务。各个参与者节点执行事务操作，并将Undo和Redo信息记录事务操作中。
各参与者向协调者反馈事务询问的结果。各个参与者根据事务操作的执行结果反馈，事务是否可以执行。

**阶段2：执行事务提交。**
协调者根据各个参与者的事务操作的执行结果，决定是否需要各个参与者提交事务。事务一旦提交就不可逆。

执行事务提交。如果所有参与者的事务操作都执行成功。那么协调者向参与者节点发送commit请求，各个参与者接收到commit请求，执行事务的提交。参与者在完成事务提交后，发送ACK消息给协调者。协调者接收到ACK后完成分布式事务。
中断事务。如果任何参与者事务操作执行失败以及等待超时还没接收到参与者事务操作执行结果，就会中断事务。协调者会向所有的参与者节点发送事务回滚请求。参与者接受到事务回滚请求后，会根据记录的undo日志记录，进行操作的回滚。参与者回滚完成事务后，向协调者发送ack消息。协调者接收到所有ack消息后，中断分布式事务。

二阶段协议可以简单的表示为投票阶段和执行阶段。投票阶段试执行并反馈结果。执行阶段根据投票阶段的执行结果，发起事务的提交或者中断操作。

**优点：**原理简单，实现方便。 
**缺点：**同步阻塞（试运行）、单点问题（协调者）、脑裂（分区，所有操作都失败）、数据不一致（如果协调者只发出部分commit消息就宕机或者发送到部分参与者的commit消息丢失，就会造成数据的不一致性）、容错性差（一旦无法获取到参与者响应，根据超时机制只能进行中断操作）。

### 2.1.4.三阶段提交协议： 
**阶段1：CanCommit**

事务询问：协调者发送CanCommit请求，询问是否可以执行事务提交操作，等待参与者回应。
参与者反馈回应：参与者根据自身情况，反馈是否能够进行执行事务操作。

**阶段2：PreCommit。**

协调者根据参与者是否能够进行事务操作的反馈结果，决定是进行事务的预提交操作还是中断操作。

预提交操作。如果所有参与者都认为自己可以进行事务操作，则进行预提交操作。协调者向所有参与者发送preCommit请求。参与者接收到preCommit请求，执行事务操作并记录redo和undo信息到事务日志中。参与者向协调者反馈自己事务操作的结果，等待协调者最终事务提交的命令。

中断操作。任何一个参与者在CanCommit阶段反馈自己不能进行事务操作或者协调者等待超时，那么就会进入中断操作。协调者向参与者发送中断请求。无论参与者接收到中断请求或者等待协调者请求超时，那么参与者会中断事务。

**阶段3：doCommit**

执行提交。所有参与者事务都可以执行成功，协调者将预提交变为提交状态，并向所有参与者发送doCommit消息。参与者接收到doCommit请求后，提交本地事务，并反馈ACK消息。协调者接收到参与者的ack消息，完成事务。
中断事务。任一个参与者返回事务操作失败或者协调者等待超时，协调者向参与者发送中断请求。参与者接收到中断操作，根据undo日志进行回滚。回滚完成后，参与者向协调者发送ack信息。协调者接收到所有ack消息，完成中断事务。
一旦进入阶段3，可能出现如下两种故障。

协调者出现问题。
协调者与参与者的网络出现故障。
只要参与者在doCommit阶段，没有接收到doCommit消息或者abort消息，在超时后，参与者会继续提交事务。 
**优点：**多了一个canCommit阶段，使得阻塞范围更小。对于单点故障也能达到（协调者在阶段3出现故障）数据的最终一致性。 
**缺点：**如果在preCommit阶段，协调者和参与者之间网络出现问题。所有参与者都将提交事务（及时abort异常），这样就造成数据的不一致性。

### 2.1.5.ZAB(ZooKeeper Atomic Broadcast) 协议
**ZAB协议又叫原子广播协议，其类似于二段提交协议，其作为ZooKeeper一致性的核心算法。 **
![img](/static/image/20170426214940585.jpg)
**zookeeper服务器集群中的服务器有三种角色：**
* 1.Learder服务所有客户端的写请求，并同步变更到Follower和Observer角色的服务器上。其与过半的Follower保持数据的强一致 
* 2.Follower作为Leader服务器的数据备份，其提供Client对于数据的读请求，同时参与Leader的选举过程和过半写成功策略。 
* 3.Observer角色，其同样作为Leader的数据备份，并处理客户端的数据读取请求。 

**ZAB协议-消息广播：**消息广播与二阶段协议的最大区别就是，二阶段协议有中断操作或者事务回滚 

![img](/static/image/20170426215847909.jpg)
* 1.客户端的写请求都会被转发Leader服务器上，其将写请求以Propose事务请求发送到所有的Follower角色服务器，并等待Follower的反馈。
* 2.Follower服务器接收到事务请求，根据事务内容进行执行，并以事务日志的形式（参考数据库的redo和undo事务日志）记录到磁盘，如果事务操作能够正常执行，并且成功记录事务日志后，会向Leader服务器发送ACK消息。如果失败，该Follower则抛弃Leader服务器。
* 3.Leader接收到过半Follower的ACK消息，则向服务器发送Commit消息，Follower接收到Commit消息后，提交事务，完成整个事务。注意：Leader在发送commit消息前以及提交自己的写请求操作。

PS:可以发现Leader和过半写成功Follower服务器数据是强一致的，然而一部分延迟的Follower和Observer与Leader数据不是强一致的，但是Zookeeper提供了sync操作（异步操作），所有的读请求都需要等待sync消息完成后，才会进行读取数据并返回结果。

**优点：**只需要过半Follower服务器写成功则整个ZooKeeper服务器的写操作完成，不需要等待所有的Follower服务都写成功了才完成写请求。因此提高了写请求的吞吐量。过半写成功保证了在崩溃恢复过程中能够快速的找到一个新的Leader并保持数据的一致性。

**ZAB协议-崩溃恢复：当Leader服务器与过半的Follower服务器失去联系或者Leader服务器宕机，则整个ZooKeeper集群进入崩溃恢复过程。 **
![img](/static/image/20170426224217828.jpg)
保证所有已经提交的事务P2能够在所有服务器提交

**场景描述：**Leader服务器在发送Commit2消息之后崩溃，ZAB需要保证所有的服务器都能够成功提交P2事务，否则会造成数据的不一致。 
![img](/static/image/20170426225525487.jpg)
保证只有Leader服务器提出的P3事务需要被丢弃

**场景描述：**Leader服务在发送P3事务之后，整个Leader服务器崩溃，导致所有的Follower服务器都没有接收到P3事务，ZAB需要保证Server1在恢复后，需要丢弃P3事务。
**针对以上两种情形，ZAB通过将崩溃恢复过程分为三个步骤来保证：**
* 1.发现过程，在多个Follower服务器进程中选取一个作为准Leader服务进程 
* 2.同步过程，保证过半的Follower服务器进程同准Leader服务器进程在数据上保持强一致性。
* 3.广播过程，准Leader进程成为Leader进程，可以进行正式的接受客户端事务请求，并进行消息广播流程。
* **发现流程：**因为所有的写请求都会转发到Leader进程，并且对于每一个事务都会分配一个单调递增的ZXID来标识事务。所以在Leader崩溃恢复过程中，只需要选取ZXID最大的事务，就可以省去事务提交和丢弃的工作。
* **同步流程：**在选择出准Leader服务器进程后，需要使得所有Follower同准Leader进程保持数据的一致性。因此准Leader会为每一个Follower服务器准备一个队列，并将那些Follower没有同步的Proposal事务发送到Follower服务器，并紧接着发送一个Commit消息，要求Follower服务器提交事务。当所有的未同步事务都提交Follower本地数据库后，将该Follower加入到Leader的Follower列表中。对于那些没有在Leader服务器上提交的P事务，由于恢复的机器（以前是Leader）的最大ZXID的事务周期小于现阶段Leader(刚崩溃的Leader)的事务ZXID，那么该恢复机器不可能成为新的Leader。在同步准Leader的事务过程中，发现有一个事务在准Leader中不具有，因此要求改服务器回退事务。当有过半的Follower同Leader服务器保持数据的强一致性后，该Leader服务器可以进行消息广播流程。
* **广播流程：**广播流程同上面的消息广播流程的二段提交协议。

### 2.1.6.AP类型分布式系统


# 3.参考

**分布式系统的基本问题：可用性与一致性**

[https://mp.weixin.qq.com/s?\_\_biz=MzIzOTU0NTQ0MA==∣=2247488548&idx=1&sn=3414db5583fc4f42a99a725423e841ff&chksm=e929292bde5ea03d17c45aa5c4d4b86a9e295c80674a17bb34a131116e5741b5d21541fb039f&mpshare=1&scene=23&srcid=10263r8WpzpkOymERUMdNo6t\#rd](https://mp.weixin.qq.com/s?__biz=MzIzOTU0NTQ0MA==&mid=2247488548&idx=1&sn=3414db5583fc4f42a99a725423e841ff&chksm=e929292bde5ea03d17c45aa5c4d4b86a9e295c80674a17bb34a131116e5741b5d21541fb039f&mpshare=1&scene=23&srcid=10263r8WpzpkOymERUMdNo6t#rd)

**分布式中间件系统的一致性和可用性：**

[https://blog.csdn.net/CWeeYii/article/details/70233933](https://blog.csdn.net/CWeeYii/article/details/70233933)

