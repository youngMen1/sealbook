# 1.基本介绍

**业务背景**：

商户提交表单数据至旺铺（deco项目，以下皆称为deco），deco需要接入poi系统进行装修内容的人工审核，详细流程见下图。

**使用实例：**做流程引擎的时候员工开单后需要审批通过后才能开单成功\(**最终一致性**\)

### **问题**：

店铺装修审核状态在deco系统和poi系统之间不一致，下图中1，2，3步提交流程会出现同一次提交审核流在deco系统中的装修状态为未装修，而在poi系统为审核中。同样在4，5，6步骤的审核回调过程也会有同类的状态不一致问题。两块问题都是同一技术问题，本文只以1，2，3步提交过程为例进行分析解决。

![img](/static/image/1305952-20180528103811932-766030002.jpg)

## 1.1.问题分析

### 1.1.1.关系型数据事务在分布式系统中的问题

从业务中抽离出来，问题的核心原因可用下图流程模型来描述。  
![img](/static/image/1305952-20180528103852437-1819386895.jpg)

**系统A的某个业务功能包含两步操作：**  
第一步把数据写入A系统本地库，  
第二步远程调用系统B，  
这两步操作在A系统用一个数据库事务来包装。  
伪代码如下：

```
$db->begain();
// 第一步操作本地数据库
$res = $db->update($sql_a);
if (!$res) {
    $db->rollback();
    return;
}
// 第二步远程调用B系统
$res = $http_request->get($url_b);
if ('success' != $res) {
    $db->rollback();
    return;
}
$db->commit();
```

**第一步有两种结果成功、失败，**  
**第二步则有3种结果成功、失败、超时，**  
其中导致超时原因可能是网络中断，也可能是B系统服务异常。  
那么我们根据两步骤的执行结果情况来分别分析一下是否会导致A、B系统之间的数据不一致。  
![img](/static/image/1305952-20180528104018507-1970560478.jpg)

可得当第一步执行成功，第二步远程调用超时时，

A系统事务会回滚，那么就发生A、B系统数据不一致的情况，

A库中写入失败，但是B库中却成功写入。

我们习惯于使用关系型数据库事务的ACID特性来达到一致性的目的，

但是当事务中发生跨系统的调用时ACID就无效了，只从数据库层面来看，跨系统就意味着同一个业务存在多个数据副本，

对应着不同的数据库实例，而且分布在不同的机器上，而关系型数据库的事务只是针对同一个库的同一个connection而言的。

##### 数据库事务的四大特性：

**1.数据库事务做了什么？**

它把数据库从一个一致的状态转换到另一个一致的状态，比如数据库操作前是一个点，数据库操作后是一个点，

我们只管这两个点的状态，而两点之间的连线上的状态我们不管因为他们可能对我们想要的结果产生影响。

**2.第一个特性 原子性（Atomicity）**

假如我们有个方法中对一个属性进行了N次的更新，但是执行到一半的时候有一个语句有问题出现了异常，这样就可能使得我们上面所说的操作后的点与我们预先的点不同，这不是我们想要的，所以原子性要求你这个方法要么全部执行成功，要么你就别执行。

**3.第二个特性 一致性（Consistency）**  
原子性中规定方法中的操作都执行或者都不执行，但并没有说要所有操作一起执行（一起更新那就乱套了，要哪个结果？），所以操作的执行也是有先后顺序的，那我们要是在执行一半时查询了数据库，那我们会得到中间的更新的属性？答案是不会的，一致性规定事务提交前后只存在两个状态，提交前的状态和提交后的状态，绝对不会出现中间的状态。

**4. 第三个特性 隔离性（Isolation）**  
事务的隔离性基于原子性和一致性，每一个事务可以并发执行，但是他们互不干扰，  
但是也有可能不同的事务会操作同一个资源，这个时候为了保持隔离性会用到锁方案。

**5. 第四个特性 持久性（Durability）**  
当一个事务提交了之后那这个数据库状态就发生了改变，哪怕是提交后刚写入一半数据到数据库中，数据库宕机\(死机\)了，那当你下次重启的时候数据库也会根据提交日志进行回滚，最终将全部的数据写入。

### 1.**2.那么怎么解决跨系统的数据一致性问题？**

#### 1.2.1.我们先重新认识一下什么是一致性？

首先想到的是关系型数据库事务，又会想到最经典的甲给乙转钱的例子，事务的四大基本特性ACID保证了甲账户扣钱和乙账户入钱同时发生或同时不发生，其中的C特性就是指一致性，它是指数据库事务不能破坏关系数据的完整性以及业务逻辑上的一致性。在web2.0之前大部分网站或者项目都是单系统，对应底层存储也只是单数据库，所以使用数据库本身的事务特性就满足了一致性。

但是随着互联网用户和数据量的指数级增长，对于每个系统的计算能力、吞吐量以及响应速度的要求都大大提高，于是单节点服务器肯定满足不了要求，所以都在考虑拆分和系统扩展性，无论是经过水平拆分还是垂直拆分，单机系统就变成了分布式系统，分布式系统就肯定存在某节点或者网络故障的情况，之前说的事务的ACID中的强一致性就无法保证。

再回到我们的问题上来，poi系统其实就可以理解为垂直拆分出的一个微服务，deco调用poi的提交审核接口就是分布式系统之间的调用，但是deco中仍然用关系型数据库的事务来达到强一致性的目的，根据CAP理论，分布式系统的一致性、可用性、分区容错性不可能同时得到满足，只能满足其中两个，而分布式系统的分区容错性都需要得到满足，所以就需要在一致性和可用性之间进行取舍。Deco的这种实现其实就是为了保证一致性，而牺牲了可用性。

而对于现在的系统而言，可用性是至关重要的必须要保证，要做到即使poi系统出现偶尔的网络故障或者超时，也尽可能不要用户的一次提交失败掉。

再来了解一个概念BASE理论，BASE理论是CAP理论的一种实现，它对分布式系统的一致性和可用性不可兼得的问题提出了一种方案，即基本可用和最终一致是目标。既然提到了强一致性和最终一致性，再介绍一下业界对一致性的分层次定义。

* **强一致 ：**当更新操作完成之后，任何多个后续进程或者线程的访问都会返回最新的更新过的值。这种是对用户最友好的，就是用户上一次写什么，下一次就保证能读到什么。根据 CAP 理论，这种实现需要牺牲可用性。

* **弱一致 **：系统并不保证续进程或者线程的访问都会返回最新的更新过的值。系统在数据写入成功之后，不承诺立即可以读到最新写入的值，也不会具体的承诺多久之后可以读到。

* **最终一致 **：弱一致性的特定形式。系统保证在没有后续更新的前提下，系统最终返回上一次更新操作的值。在没有故障发生的前提下，不一致窗口的时间主要受通信延迟，系统负载和复制副本的个数影响。DNS 是一个典型的最终一致性系统。

  **对上面几段分析的总结就是：**关系型数据库的事务可以满足单系统的强一致性，大部分分布式系统只能把最终一致性作为追求。而我们的deco和poi系统显然也是应该追求最终一致性，因为对于poi和deco之间装修审核数据出现短时间的不一致是完全可以接受的。

#### **1.2.2.分布式理论：BASE理论**

# 2.怎么使用

# 3.总结

# 4.参考

原文链接：
https://blog.csdn.net/xinyalong/java/article/details/92796087

分布式系统一致性问题解决实战：
https://www.cnblogs.com/kerwing/p/9098893.html  
分布式理论: BASE理论   
[https://www.cnblogs.com/kerwing/p/9098893.html](https://www.cnblogs.com/kerwing/p/9098893.html)

