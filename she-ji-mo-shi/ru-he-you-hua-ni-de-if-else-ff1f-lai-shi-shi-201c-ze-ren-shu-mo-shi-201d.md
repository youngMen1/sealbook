# 如何优化你的if-else？来试试“责任树模式”
`简介：写业务逻辑时，if-else 可能是最容易想到的逻辑方式了。然而大量堆砌的 if-else 毫无疑问将给代码维护带来巨大的困难。如何优化这些 if-else 呢？本文分享一种设计模式——责任树模式，通过将责任链与策略模式融合，成为一种广义的责任链模式，不仅可以完成任务的逐级委托，也可以在任一级选择不同的下游策略进行处理，并将责任树模式抽象出一个通用的框架。`

## 一、问题背景
最近开发了一个需求，该接口需要根据 p1、p2、p3、version 多个入参的不同组合按照其对应的业务策略给出结果数据。由于该接口已经开发了三期了，每次开发新一期的需求时为了兼容老的业务逻辑，大家都倾向于不删不改只新增，因此这块代码已经产生了一些“坏味道”，函数入口通过不断添加“卫语句”判断 version 的方式跳转到新一期的业务逻辑方法中，而每一期的业务逻辑也是通过 p1、p2、p3 的 if-else 组合形成不同的分支逻辑。这已经是我简化后的表述，总之刚开始对于我这个新同学来说，梳理这块业务代码着实花了一些功夫。

![](/static/image/微信图片_20210203110049.gif)


而且，这块逻辑相当于是一个业务上的通用能力，未来一定还会有五期、六期、N 期的需求进来，入参的取值也会不断拓展，因此以现有方式膨胀下去只会“坏味道”会越来越重。

总结一下，当前场景面临的问题是：

* 如何解决接口升级，在保证兼容老版本的情况下轻松开发新版本业务逻辑？

* 如何根据入参 p1、p2、p3 等的不同组合进行策略定位？


## 二、解决思路

在思考解决方案时，很容易想到两种可以优化类似场景的设计模式：责任链模式和策略模式。

1、责任链模式

责任链模式是实现了类似“流水线”结构的逐级处理，通常是一条链式结构，将“抽象处理者”的不同实现串联起来：如果当前节点能够处理任务则直接处理掉，如果无法处理则委托给责任链的下一个节点，如此往复直到有节点可以处理这个任务。

我们可以通过责任链模式完成对不同 version 业务逻辑隔离的处理，比如节点 1 处理 version = 1 的请求，节点 2 处理 version = 2 的请求等等。但问题在于我们遇到的场景还需要根据一定策略，路由到不同的下游节点进行处理。这就是策略模式擅长解决的问题了。

![](/static/image/微信图片_20210203110857.png)

2、策略模式

策略模式的目的是将算法的使用与定义解耦，能够实现根据规则路由到不同策略类进行处理。

我们可以通过策略模式解决根据不同参数组合执行不同业务逻辑的场景。但是我们的场景仅仅通过一层策略路由无法满足任务处理需求。请求的分层处理又是责任链模式所擅长的了。
微信图片_20210203111658.png

可以看到，两种设计模式都不完全符合目前这个场景：责任链模式可以实现逐级委托，但每一级又不能像策略模式那样路由到不同的处理者上；策略模式通常只有一层路由，不易实现多个参数的策略组合。

因此我们自然而然地可以想到：是不是可以将两种模式结合起来？

3、广义责任链模式——责任树模式

将责任链与策略模式融合，即成为了一种广义的责任链模式，我简称为“责任树模式”。这种模式不仅可以完成任务的逐级委托，也可以在任一级选择不同的下游策略进行处理。

微信图片_20210203111729.png

那么问题来了，如何通过责任树模式解决前面我们遇到的问题呢？

首先看如何解决第一个问题，新老接口的隔离和兼容：可以将接口每个版本的逻辑作为一个责任树上第一层的不同实现，如分别对应上图中的 Strategy1、Strategy2、Strategy3 节点。这样在接口入口，就首先把策略路由到不同的分支上去。如果没有节点命中，则不再向下游委托直接返回错误。

然后第二个问题，参数的组合定位到不同的策略实现上：同样的思路，一个参数对应责任树上的一层的路由，将该参数的不同取值路由到下一层的不同实现即可，这样逐级委托，后面新增入参的枚举值、甚至再拓展新的入参都可以非常方便地进行拓展。

三、优化收益
将这块业务通过“责任树模式”重构之后，可以收获以下几个收益点：

后续迭代人力成本降低。

代码结构更清晰，可维护性提升：没有了各种“卫语句”的跳转 & 维护性巨差的巨型方法，函数可以收敛在理想的 50 行内。

后续新增需求修改代码不易出错：策略间隔离，不需要完整看一遍大函数理清逻辑再修改，只需要无脑添加一条路由 + 新的策略实现方法即可。

问题易定位：同样由于策略间隔离，调试时可以直接定位到指定策略的业务逻辑代码，不需要逐句排查。

相信有开发经验的同学应该都有体会，即使是自己写过的代码，一阵子不看也会忘掉，等到再有修改时，还要顺着代码理一遍逻辑，如果文档、注释没写好，那就更加酸爽了。因此，将巨型函数拆分解耦非常重要。